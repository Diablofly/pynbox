#!/bin/bash

# This is written in bash so that it's possible to use pynbox to install sandboxed Python without
# requiring unsandboxed Python just for the installation.

DEFAULT_REPO="build/outputs,https://pynbox.org/repo"
UPLOAD_REPO="s3://grist-pynbox/packages"

DOCKER_IMAGE=pynbox-webports
DOCKER_CONTAINER=pynbox-webports1

USAGE="Usage: $0 [-h] [-v] {install|build|upload} [args]

COMMANDS:
  install <dest> <pkg>[=VER] ...  Install a pynbox component; allows optional =VER suffixes.
  build <pkg> ...                 Build a pynbox component from source.
  upload <pkg> ...                Upload a build pynbox component to online repo.
  startdocker                     Start docker container (done by 'build' if needed).
  stopdocker                      Stop docker container, to clean up after building.

OPTIONS:
  <pkg>           The package to build or install, which may be:
                    'sandbox_outer' The trusted (host) part of the sandbox code.
                    'sandbox_inner' The inner part of the sandbox code.
                    'python'        Python2 sandboxed interpreter and core modules.
                    'python3'       Python3 sandboxed interpreter and core modules.
                    <module>        Any Python module available in the repo.
  <dest>          [for install] Destination directory for the install.
  --repo SOURCES  [for install] Search for built components in the given sources, which are a
                  comma-separated list of directories of URLs (the latter must start with
                  http:// or https://). By default, searches $DEFAULT_REPO
  â€”-dest REPO-URL [for upload] The repository to upload it to. By default, $UPLOAD_REPO
  -h, --help      Display this help and exit.
  -v, --verbose   Be more verbose.
"

# Settings for script robustness.
set -o pipefail  # trace ERR through pipes
set -o nounset   # same as set -u : treat unset variables as an error
set -o errtrace  # same as set -E: inherit ERR trap in functions
trap 'echo Error in line "${BASH_SOURCE}":"${LINENO}"; exit 1' ERR
trap 'echo "Exiting on interrupt"; exit 1' INT

ACTION=
SOURCES=
VERBOSE=

usage_exit() {
  echo "$USAGE"
  exit 2
}

process_options() {
  while [[ $# > 0 ]]; do
    case "$1" in
      -v|--verbose)
        VERBOSE=yes
        ;;
      install|build|upload|startdocker|stopdocker)
        ACTION="$1"
        ;;
      --repo)
        SOURCES="$2"
        shift
        ;;
      --dest)
        UPLOAD_REPO="$2"
        shift
        ;;
      -h|--help|-*)
        usage_exit
        ;;
      *)
        break
        ;;
    esac
    shift
  done
  if [[ -z "$ACTION" ]]; then usage_exit; fi
  ARGS="$@"
}

process_options "$@"

do_install() {
  if [[ $# -lt 2 ]]; then usage_exit; fi
  local dest=$1
  shift
  mkdir -p "$dest"
  for package_ver in "$@"; do
    if [[ "$package_ver" == *=* ]]; then
      local package=${package_ver%%=*}
      local version=${package_ver/*=}
    else
      local package="$package_ver"
      local script=packages/${package}.create.sh
      local version="$($script --version)"
    fi
    local archive=build/packages/${package}.${version}.tbz2
    echo "Installing $archive into $dest"
    tar -C $dest -jxf $archive
  done
}

# Outputs "running" if running, something else otherwise.
docker_container_status() {
  docker inspect --type=container --format='{{.State.Status}}' $DOCKER_CONTAINER 2>/dev/null || true
}

do_startdocker() {
  if [[ $# != 0 ]]; then usage_exit; fi

  # See if our docker container is running.
  if [[ "$(docker_container_status)" = "running" ]]; then
    echo "Docker container $DOCKER_CONTAINER already running"
  else
    # See if our image exists, or needs to be built.
    if [[ -z $(docker images -q $DOCKER_IMAGE 2>/dev/null) ]]; then
      echo "Building docker image $DOCKER_IMAGE"
      docker build -t $DOCKER_IMAGE webports/
    fi

    # Clean up an existing container if needed.
    if [[ "$(docker_container_status)" != "" ]]; then
      echo "Removing non-running container $DOCKER_CONTAINER"
      docker rm $DOCKER_CONTAINER > /dev/null
    fi

    echo "Starting docker container $DOCKER_CONTAINER from image $DOCKER_IMAGE"
    # The extra slash in front helps it work on Windows and doesn't hurt Unix-like systems.
    docker run -it -d --name $DOCKER_CONTAINER \
      -v /`pwd`/packages:/host/packages:ro \
      $DOCKER_IMAGE
  fi
}

do_build() {
  if [[ $# -lt 1 ]]; then usage_exit; fi
  for package in "$@"; do
    echo "----------------------------------------"
    echo "Building $package"
    echo "----------------------------------------"
    local script=packages/${package}.create.sh
    local version="$($script --version)"
    local target=build/packages/${package}.${version}.tbz2

    do_startdocker

    if [[ ! -x "$script" ]]; then
      echo "$script must exist and be executable"
      exit 1
    fi

    if [[ -e $target ]]; then
      echo "Removing previous version of $target"
      rm $target
    fi

    echo "Using container $DOCKER_CONTAINER to build $package"
    if [[ "$package" == "sandbox_outer" ]]; then
      $script $target
    else
      docker exec $DOCKER_CONTAINER "/host/$script" /$target
      docker cp $DOCKER_CONTAINER:/$target $target
    fi
    if [[ -e $target ]]; then
      echo "Built $target"
    else
      echo "Expected $target to be built, but it wasn't!"
      exit 1
    fi
  done
}

do_stopdocker() {
  if [[ $# != 0 ]]; then usage_exit; fi

  if [[ "$(docker_container_status)" = "running" ]]; then
    echo "Stopping and removing docker container $DOCKER_CONTAINER"
    docker stop $DOCKER_CONTAINER > /dev/null
    docker rm $DOCKER_CONTAINER > /dev/null
  elif [[ "$(docker_container_status)" != "" ]]; then
    echo "Removing non-running container $DOCKER_CONTAINER"
    docker rm $DOCKER_CONTAINER > /dev/null
  else
    echo "Docker container $DOCKER_CONTAINER is not running"
  fi
}

check_upload_exists() {
  local dest="$UPLOAD_REPO/$(basename $1)"
  if [[ "$UPLOAD_REPO" == s3:/* ]]; then
    aws --profile pynbox s3 ls "$dest" > /dev/null
  else
    [[ -e "$dest" ]]
  fi
}


upload_file() {
  local path="$1"
  local basename="$(basename $path)"
  local dest="$UPLOAD_REPO/$basename"

  if [[ "$UPLOAD_REPO" == s3:/* ]]; then
    aws --profile pynbox s3 cp "$path" "$dest" ||
      ( echo "To upload to S3, you must have 'aws' client installed, and ";
        echo "suitable credential configured for profile 'pynbox'";
        exit 1 )
  else
    mkdir -p $UPLOAD_REPO
    cp -v "$path" "$dest"
  fi
}

do_upload() {
  if [[ $# -lt 1 ]]; then usage_exit; fi

  for package in "$@"; do
    local script=packages/${package}.create.sh
    local version="$($script --version)"
    if check_upload_exists ${package}.${version}.tbz2 ; then
      echo "Package $UPLOAD_REPO/${package}.${version}.tbz2 already exists."
      echo "To update a new version, update VERSION in $script."
      echo "To replace this version in the repo, remove the package from the repo first."
      exit 1
    fi
  done

  for package in "$@"; do
    local script=packages/${package}.create.sh
    local version="$($script --version)"
    upload_file build/packages/${package}.${version}.tbz2
  done
}

do_$ACTION ${ARGS[@]}
